<html>
	<head>
		<title>Hubway Routes</title>
		<script type="text/javascript" src = "underscore-min.js"></script>
		<script type="text/javascript" src = "backbone-min.js"></script>
		<script type="text/javascript" src = "d3/d3.v2.js"></script>
		<style type="text/css">
			body {
				font-family:"helvetica neue","helvetica",sans-serif;
				font-size:0.8em;
			}
			
			.container svg {
			
				
			}
			
			/* no axis line */
			.axis path {
				fill: none;
			}
			.axis line {
				fill: none;
				stroke: black;
				shape-rendering: crispEdges;
			}
			
			.infohead ul {
				
				margin:0;
				padding:0.5em;
				list-style:none;
			}
			
		</style>
	</head>
	<body>
		<div style="margin-bottom:30px; margin-left:10px; width:950px;">
			<div style="display:inline-block;float:left;">
				<h1 style="margin:0;">Hubway Bike Race!!!!!</h1>
				Which Hubway bike will be the first ridden to 1000 miles?!
			</div>
			
			<div style="display:inline-block;border:1px solid; margin-left:1em;float:right;" class="infohead">
				<ul>
					<li>made by <a href="https://twitter.com/athst">Jon Nguyen</a></li>
					<li>for the <a href="http://hubwaydatachallenge.org/">Hubway Data Viz Challenge</a></li>
					<li>with <a href="http://d3js.org/">D3.js</a></li>
				</ul>
			</div>
			
			<div style="display:inline-block; float:right;">
				<h1 class="announce" style="margin:0;">Ready...</h1>
			</div>
			
			<div style="display:inline-block;border:1px solid; margin-left:1em;" class="infohead">
				<ul>
					<li><a href="#">replay</a></li>
					<li>race call <input type="checkbox" onchange="toggleRaceCall();" checked></li>
					<li>sort <input type="checkbox" onchange="toggleSort();" checked></li>
				</ul>
			</div>
		</div>
		
		<script type="text/javascript">
			
			// much of this cobbled together from several of mike bostock's examples including https://gist.github.com/1584697
	
			// global variables like this is probably not the right way
			var data;
			var svg;
			var x;
			var y;
			var margin;
			var width;
			var height;
			var intervalTimer;
			//var altKey; // only used if doing the bar transition animations
			
			// create toggles to control these options
			var sort = true;
			var racecall = true;
			
			function toggleSort() {
				sort = !sort
			}
			
			function toggleRaceCall() {
				racecall = !racecall
			}
			
			
			// update the announce field
			function bigboard(message) {
				
					d3.select(".announce").html(message);
				
			}
			
			/*
			var m1 = "Ready...";
			var m2 = "Set...";
			setTimeout(bigboard(m1),1000);
			setTimeout(bigboard(m2),1000);
			*/
			
			// Load the route data from CSV
			d3.csv('bikedaily.csv', function(rows) {
				
				// collect the data into groups by bike
				bikes = _.groupBy(rows,function(row){return row.bike_nr;})
		
				data = d3.entries(bikes)
		
				// set up chart area
				margin = {top: 20, right: 10, bottom: 20, left: 50},
					width = 960 - margin.left - margin.right,
					height = 10000 - margin.top - margin.bottom;
					
				svg = d3.select("body").append("svg")
					.attr("width", width + margin.left + margin.right)
					.attr("height", height + margin.top + margin.bottom)
				  .append("g")
					.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
					
				// set up the scales based on the data
				x = d3.scale.linear()
					.domain([0, 1150])  // should probably change this to something dependent on the data
					.range([0, width]);
				
				y = d3.scale.ordinal()
					.domain(d3.range(data.length))
					.rangeBands([0, height], .1);
				
				// put an axis on the top
				svg.append("g")  // appends a new group element
					.attr("class", "x axis")
					//.attr("transform", "translate(0," + height + ")")
					.attr("transform", "translate(0,0)")
					.call(d3.svg.axis()
					.scale(x)
					.orient("top"));
				
				// put an axis on the bottom too because it's a tall graph
				svg.append("g")  // appends a new group element
					.attr("class", "x axis")
					.attr("transform", "translate(0," + height + ")")
					//.attr("transform", "translate(0,0)")
					.call(d3.svg.axis()
					.scale(x)
					.orient("bottom"));
				
				
				/* extract the array of unique date values from the data set */
				// pluck out an array of dates for each bike
				datearrays = _(data).map(function(datum){return _.pluck(datum.value,'date');})
				
				// flatten, sort, and unique the resulting data Array
				// in the future, would be better to just have this and not calculate it, because it's expensive
				daterange = _.sortBy(_.flatten(datearrays),function(datevalue) {return datevalue;})
				daterange = _.uniq(daterange,true)	// unique the values - pass true to tell it that it's already sorted
				
				// create container array to hold the cumulative values
				
				biketotals = _.map(data, function(bike) {
				
						bikeobj = new Object();
						bikeobj.key = bike.key;
						bikeobj['total_miles'] = 0;
						bikeobj['total_trips'] = 0;
						return bikeobj;
					})
				
				bigboard("Ready...");
				bigboard("Set...");
				bigboard("Go!!!");
				
				// when the data is loaded, set the timer and start drawing the graph
				intervalTimer = setInterval(function() {
					
					// pull out the next date from the array
					datetograph = daterange.shift();
				
					dailytotals2 = _.map(data, function(bike) {
					
						return _.find(bike.value,function(bikeday) {return bikeday['date'] == datetograph})
					})
					
					// remove all the bikes from the array that didn't have any values for the datearrays
					// there is probably a better way to do this in one step but I couldn't find it
					dailytotals2 = _.compact(dailytotals2)
					
					// add the daily distance and trip totals to the bike array
					// this is really expensive - need to find a more efficient way of doing this step
					dailytotals2.forEach(function(bikeday) {
					
						bike = _.find(biketotals,function(bike){return bike.key == bikeday.bike_nr});
						
						// need to do parseFloat or else it tries to add strings together and it fucks up
						bike['total_miles'] = parseFloat(bike['total_miles']) + parseFloat(bikeday['distance']);
						bike['total_trips'] = parseFloat(bike['total_trips']) + parseFloat(bikeday['trip_count']);
						
						});
					
					// draw the date with the new calculations
					
					redraw(biketotals,datetograph);
					bigboard(datetograph);
					// animating the sort like this looks jerky and awful - need to find a way to make it smoother
					/*
					d3.transition()
						.duration(500)
						.each(redraw(biketotals,datetograph));
					*/
					
				}, 100);  // 500 = .5 seconds
			})
		
				
			// add some nice colors
			var fill = d3.scale.category10();
			
			/* this draws all of the bars */
			function redraw(biketotals,dateString) {
			
				// sort the bars if the option toggle is enabled
				if (sort) {
					biketotals.sort(function(a,b) {
					
						// sort based on total miles descending
						return b.total_miles - a.total_miles;
						
					});
				}
				else {
					// don't sort, duh!	
				}
				
				y.domain(biketotals.map(function(d) {return d.key;}));
				
				// get the existing bars that are already on the graph, use key to determine which already exists
				// this might be where I need to do the keying shit
				var bar = svg.selectAll(".bar")
					.data(biketotals, function(d) {return d.key});

				// ENTER - add new bars that weren't there before, according to the key
				// make sure to give it the appropriate bar class
				var barEnter = bar.enter().insert("g",".axis")
					.attr("class", "bar")
					.attr("transform", function(d, i) { return "translate(0," + y(i) + ")"; })
					.style("fill-opacity",0)
					.style("fill",function(d) {return fill(d.key);});
				
				barEnter.append("rect")
					.attr("height", y.rangeBand())
					.attr("width", function(d) {
					
						return x(d['total_miles'])
						
					});
			
				barEnter.append("text")
					.attr("text-anchor", "end")
					.attr("x", function(d) { return x(d) - 6; })
					.attr("y", y.rangeBand() / 2)
					.attr("dy", ".35em")
					.text(function(d, i) { return d.key; });
				
				// UPDATE - update values for the bars that were there before, according to the key
				
				var barUpdate = d3.transition(bar)
					//.attr("transform", function(d,i) {return "translate(0," + (d.y0 = y(i)) + ")"; })
					.attr("transform", function(d,i) {return "translate(0," + (d.y0 = y(d.key)) + ")"; })
					.style("fill-opacity", 1);
				
				barUpdate.select("rect")
					.attr("width", function(d) {
					
						return x(d['total_miles'])
						
					});
				
				// EXIT
				
				var barExit = d3.transition(bar.exit())
					.attr("transform", function(d) {return "translate(0," + (d.y0 + height) + ")"; })
					.style("fill-opacity",0)
					.remove();
				
				barExit.select("rect")
					.attr("width", function(d,i) {
					
						return x(d['total_miles'])
						
					});
				
				// clear the timer when we're done so it doesn't continue forever
				if (daterange.length <= 0) {
					clearInterval(intervalTimer);
				}
				
			}
			
		</script>
	</body>
</html>